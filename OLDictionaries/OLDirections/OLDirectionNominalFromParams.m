function direction = OLDirectionNominalFromParams(directionParams,backgroundPrimary,calibration,varargin)
% Generate a parameterized direction from the given parameters
%
% Syntax:
%   direction = OLDirectionNominalFromParams(directionParameters)
%
% Description:
%    For several common types of directions, this function can generate the
%    actual direction from parameters.
%
%    This function currently knows about the following types:
%       - unipolar
%       - bipolar
%       - lightfluxchrom
%
%    These parameters can be generated by OLDirectionParamsDefaults,
%    validated by OLDirectionParamsValidate, and several sets of
%    parameters are predefined in OLDirectionParamsDictionary.
%
% Inputs:
%    directionParams - struct defining the parameters for a type of
%                       direction. Can be generated using
%                       OLDirectionParamsDefaults
%
% Outputs:
%    direction       - a 1x60 struct array (one struct per observer age
%                      1:60 yrs), with the following fields:
%                         * backgroundPrimary
%                         * backgroundSpd
%                         * modulationPrimarySignedPositive
%                         * modulationSpdSignedPositive
%                         * describe
%
% Optional key/value pairs:
%    'verbose'        - boolean flag to print output. Default false.
%
% Notes:
%    None.
%
% See also:
%    OLDirectionNominalParamsDefaults, OLDirectionNominalParamsValidate,
%    OLDirectionNominalParamsDictionary

% History:
%    01/31/18  jv  wrote it, based on OLWaveformFromParams and
%                  OLReceptorIsolateMakeDirectionNominalPrimaries

%% Input validation
parser = inputParser();
parser.addRequired('directionParams',@isstruct);
parser.addRequired('backgroundPrimary');
parser.addRequired('calibration',@isstruct);
parser.addParameter('verbose',false,@islogical);
parser.parse(directionParams,backgroundPrimary,calibration,varargin{:});

S = calibration.describe.S;
backgroundSpd = OLPrimaryToSpd(calibration, backgroundPrimary);

%% Generate direction
switch directionParams.type
    case {'bipolar', 'unipolar'}
        % Pupil diameter in mm.
        pupilDiameterMm = directionParams.pupilDiameterMm;
        
        % Photoreceptor classes: cell array of strings
        photoreceptorClasses = directionParams.photoreceptorClasses;
        
        % Set up what will be common to all observer ages
        % Pull out the 'M' matrix
        B_primary = calibration.computed.pr650M;
        
        % Set up some parameters for the optimization
        whichPrimariesToPin = [];       % Primaries we want to pin
        whichReceptorsToIgnore = directionParams.whichReceptorsToIgnore;    % Receptors to ignore
        whichReceptorsToIsolate = directionParams.whichReceptorsToIsolate;    % Receptors to stimulate
        whichReceptorsToMinimize = directionParams.whichReceptorsToMinimize;
        
        % Peg desired contrasts
        desiredContrasts = directionParams.modulationContrast;
        
        % Assign a zero 'ambientSpd' variable if we're not using the
        % measured ambient.
        if directionParams.useAmbient
            ambientSpd = calibration.computed.pr650MeanDark;
        else
            ambientSpd = zeros(size(B_primary,1),1);
        end
        
        if (parser.Results.verbose), fprintf('\nGenerating stimuli which isolate receptor classes:'); end
        for i = 1:length(whichReceptorsToIsolate)
            if (parser.Results.verbose), fprintf('\n  - %s', photoreceptorClasses{whichReceptorsToIsolate(i)}); end
        end
        if (parser.Results.verbose), fprintf('\nGenerating stimuli which ignore receptor classes:'); end
        if ~isempty(whichReceptorsToIgnore)
            for i = 1:length(whichReceptorsToIgnore)
                if (parser.Results.verbose), fprintf('\n  - %s', photoreceptorClasses{whichReceptorsToIgnore(i)}); end
            end
        else
            if (parser.Results.verbose), fprintf('\n  - None'); end
        end
        
        % Make direction information for each observer age
        for observerAgeInYears = 20:60
            % Say hello
            if (parser.Results.verbose), fprintf('\nObserver age: %g\n',observerAgeInYears); end
            
            % Get fraction bleached for background we're actually using
            if (directionParams.doSelfScreening)
                fractionBleached = OLEstimateConePhotopigmentFractionBleached(S,backgroundSpd,pupilDiameterMm,directionParams.fieldSizeDegrees,observerAgeInYears,photoreceptorClasses);
            else
                fractionBleached = zeros(1,length(photoreceptorClasses));
            end
            
            % Get lambda max shift.  Currently not passed but could be.
            lambdaMaxShift = [];
            
            % Construct the receptor matrix based on the bleaching fraction to this background.
            T_receptors = GetHumanPhotoreceptorSS(S,photoreceptorClasses,directionParams.fieldSizeDegrees,observerAgeInYears,pupilDiameterMm,lambdaMaxShift,fractionBleached);
            
            % Calculate the receptor coordinates of the background
            backgroundReceptors = T_receptors*backgroundSpd;
            
            % Isolate the receptors by calling the ReceptorIsolate
            initialPrimary = backgroundPrimary;
            modulationPrimarySignedPositive = ReceptorIsolate(T_receptors, whichReceptorsToIsolate, ...
                whichReceptorsToIgnore,whichReceptorsToMinimize,B_primary,backgroundPrimary,...
                initialPrimary,whichPrimariesToPin,directionParams.primaryHeadRoom,directionParams.maxPowerDiff,...
                desiredContrasts,ambientSpd);
            
            % Look at both negative and positive swing and double check that we're within gamut
            differencePrimary = modulationPrimarySignedPositive - backgroundPrimary;
            modulationPrimarySignedPositive = backgroundPrimary+differencePrimary;
            modulationPrimarySignedNegative = backgroundPrimary-differencePrimary;
            if any(modulationPrimarySignedNegative > 1) || any(modulationPrimarySignedNegative < 0)  || any(modulationPrimarySignedPositive > 1)  || any(modulationPrimarySignedPositive < 0)
                error('Out of bounds.')
            end
            
            % Compute spds, constrasts
            differenceSpdSignedPositive = B_primary*differencePrimary;
            differenceReceptorsPositive = T_receptors*differenceSpdSignedPositive;
            isolateContrastsSignedPositive = differenceReceptorsPositive ./ backgroundReceptors;
            modulationSpdSignedPositive = backgroundSpd+differenceSpdSignedPositive;
            
            differenceSpdSignedNegative = B_primary*(-differencePrimary);
            modulationSpdSignedNegative = backgroundSpd+differenceSpdSignedNegative;
            
            % Print out contrasts. This routine is in the Silent Substitution Toolbox.
            if (parser.Results.verbose), ComputeAndReportContrastsFromSpds(sprintf('\n> Observer age: %g',observerAgeInYears),photoreceptorClasses,T_receptors,backgroundSpd,modulationSpdSignedPositive,[],[]); end
            
            % [DHB NOTE: MIGHT WANT TO SAVE THE VALUES HERE AND PHOTOPIC LUMINANCE TOO.]
            % Print out luminance info.  This routine is also in the Silent Substitution Toolbox
            if (parser.Results.verbose), GetLuminanceAndTrolandsFromSpd(S, backgroundSpd, pupilDiameterMm, true); end
            
            %% Assign all the cache fields
            %
            % Description
            direction(observerAgeInYears).describe.params = directionParams;
            direction(observerAgeInYears).describe.B_primary = B_primary;
            direction(observerAgeInYears).describe.ambientSpd = ambientSpd;
            direction(observerAgeInYears).describe.photoreceptors = photoreceptorClasses;
            direction(observerAgeInYears).describe.lambdaMaxShift = lambdaMaxShift;
            direction(observerAgeInYears).describe.fractionBleached = fractionBleached;
            direction(observerAgeInYears).describe.S = S;
            direction(observerAgeInYears).describe.T_receptors = T_receptors;
            direction(observerAgeInYears).describe.S_receptors = S;
            direction(observerAgeInYears).describe.contrast = isolateContrastsSignedPositive;
            direction(observerAgeInYears).describe.contrastSignedPositive = isolateContrastsSignedPositive;
                      
            % Modulation (positive)
            direction(observerAgeInYears).modulationPrimarySignedPositive = modulationPrimarySignedPositive;
            direction(observerAgeInYears).modulationSpdSignedPositive = modulationSpdSignedPositive;
            
            % Background
            if (strcmp(directionParams.type,'unipolar'))
                direction(observerAgeInYears).backgroundPrimary = modulationPrimarySignedNegative;
                direction(observerAgeInYears).backgroundSpd = modulationSpdSignedNegative;
            else
                direction(observerAgeInYears).backgroundPrimary = backgroundPrimary;
                direction(observerAgeInYears).backgroundSpd = backgroundSpd;
            end
            clear modulationPrimarySignedNegative modulationSpdSignedNegative
        end
        
    case 'lightfluxchrom'
        % A light flux pulse or modulation, computed given background.
        % 
        % Note: This has access to useAmbient and primaryHeadRoom parameters but does
        % not currently use them. That is because this counts on the background having
        % been set up to accommodate the desired modulation.
        
        % Modulation.  This is the background scaled up by the factor that the background
        % was originally scaled down by.
        modulationPrimarySignedPositive = backgroundPrimary*directionParams.lightFluxDownFactor;
        modulationSpdSignedPositive = OLPrimaryToSpd(calibration, modulationPrimarySignedPositive);
        
        % Check gamut
        if (any(modulationPrimarySignedPositive > 1) || any(modulationPrimarySignedPositive < 0))
            error('Out of gamut error for the modulation');
        end
        
        % Replace the values
        for observerAgeInYrs = 20:60
            direction(observerAgeInYrs).backgroundPrimary = backgroundPrimary;
            direction(observerAgeInYrs).backgroundSpd = backgroundSpd;
            direction(observerAgeInYrs).modulationPrimarySignedPositive = modulationPrimarySignedPositive;
            direction(observerAgeInYrs).modulationSpdSignedPositive = modulationSpdSignedPositive;
            direction(observerAgeInYrs).describe.params = directionParams;
        end

    otherwise
        error('Unknown direction type specified');
end

end